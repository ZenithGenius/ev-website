/*! For license information please see 599.min.js.LICENSE.txt */
(this.webpackChunk_tsparticles_all=this.webpackChunk_tsparticles_all||[]).push([[599],{599:(a,e,t)=>{t.d(e,{GradientUpdater:()=>u});var i=t(3624);class s{constructor(){this.count=0,this.enable=!1,this.speed=0,this.decay=0,this.delay=0,this.sync=!1,this.startValue="random"}load(a){a&&(void 0!==a.count&&(this.count=(0,i.Cs)(a.count)),void 0!==a.enable&&(this.enable=a.enable),void 0!==a.speed&&(this.speed=(0,i.Cs)(a.speed)),void 0!==a.sync&&(this.sync=a.sync),void 0!==a.startValue&&(this.startValue=a.startValue),void 0!==a.decay&&(this.decay=(0,i.Cs)(a.decay)),void 0!==a.delay&&(this.delay=(0,i.Cs)(a.delay)))}}class o{constructor(){this.value=0,this.animation=new s}load(a){a&&(this.animation.load(a.animation),void 0!==a.value&&(this.value=(0,i.Cs)(a.value)))}}class n{constructor(){this.stop=0,this.value=new i.RC}load(a){a&&(void 0!==a.stop&&(this.stop=a.stop),this.value=i.RC.create(this.value,a.value),void 0!==a.opacity&&(this.opacity=new o,(0,i.hj)(a.opacity)?this.opacity.value=a.opacity:this.opacity.load(a.opacity)))}}class c{constructor(){this.count=0,this.enable=!1,this.speed=0,this.decay=0,this.delay=0,this.sync=!1}load(a){a&&(void 0!==a.count&&(this.count=(0,i.Cs)(a.count)),void 0!==a.enable&&(this.enable=a.enable),void 0!==a.speed&&(this.speed=(0,i.Cs)(a.speed)),void 0!==a.decay&&(this.decay=(0,i.Cs)(a.decay)),void 0!==a.delay&&(this.delay=(0,i.Cs)(a.delay)),void 0!==a.sync&&(this.sync=a.sync))}}class l{constructor(){this.value=0,this.animation=new c,this.direction="clockwise"}load(a){a&&(this.animation.load(a.animation),void 0!==a.value&&(this.value=(0,i.Cs)(a.value)),void 0!==a.direction&&(this.direction=a.direction))}}class d{constructor(){this.angle=new l,this.colors=[],this.type="random"}load(a){a&&(this.angle.load(a.angle),void 0!==a.colors&&(this.colors=a.colors.map((a=>{const e=new n;return e.load(a),e}))),void 0!==a.type&&(this.type=a.type))}}const r=2*Math.PI;class u{getColorStyles(a,e,t,s){const o=a.gradient;if(!o)return{};const n=o.angle.value,c=0,l=0,d="radial"===o.type?e.createRadialGradient(c,l,0,c,l,t):e.createLinearGradient(Math.cos(n)*-t,Math.sin(n)*-t,Math.cos(n)*t,Math.sin(n)*t);for(const{stop:a,value:e,opacity:t}of o.colors)d.addColorStop(a,(0,i.vz)({h:e.h.value,s:e.s.value,l:e.l.value},t?.value??s));return{fill:d}}async init(a){const e=(0,i.wA)(a.options.gradient);if(!e)return;const{angle:t}=e;a.gradient={angle:{value:(0,i.Gu)(t.value),enable:t.animation.enable,velocity:(0,i.Gu)(t.animation.speed)/360*a.container.retina.reduceFactor,decay:1-(0,i.Gu)(t.animation.decay),delayTime:(0,i.Gu)(t.animation.delay)*i.X5,max:r,min:0,time:0},type:e.type,colors:[]};let s=e.angle.direction;switch("random"===s&&(s=(0,i.sZ)()>i.vq?"counter-clockwise":"clockwise"),s){case"counter-clockwise":case"counterClockwise":a.gradient.angle.status="decreasing";break;case"clockwise":a.gradient.angle.status="increasing"}const o=a.options.reduceDuplicates;for(const t of e.colors){const e=(0,i.lN)(t.value,a.id,o);if(!e)continue;const s=(0,i.bS)(e,t.value.animation,a.container.retina.reduceFactor),n={stop:t.stop,value:s,opacity:t.opacity?{enable:t.opacity.animation.enable,max:(0,i.KI)(t.opacity.value),min:(0,i.Uv)(t.opacity.value),status:"increasing",value:(0,i.Gu)(t.opacity.value),velocity:(0,i.Gu)(t.opacity.animation.speed)/i.tZ*a.container.retina.reduceFactor,decay:1-(0,i.Gu)(t.opacity.animation.decay),delayTime:(0,i.Gu)(t.opacity.animation.delay)*i.X5,time:0}:void 0},{opacity:c}=n;if(t.opacity&&c){const a=t.opacity.value;c.min=(0,i.Uv)(a),c.max=(0,i.KI)(a);switch(t.opacity.animation.startValue){case"min":c.value=c.min,c.status="increasing";break;case"max":c.value=c.max,c.status="decreasing";break;default:c.value=(0,i.vd)(c),c.status=(0,i.sZ)()>=i.vq?"increasing":"decreasing"}}a.gradient.colors.push(n)}await Promise.resolve()}isEnabled(a){return!a.destroyed&&!a.spawning&&(!!a.gradient?.angle.enable||(a.gradient?.colors.some((a=>a.value.h.enable||a.value.s.enable||a.value.l.enable))??!1))}loadOptions(a,...e){for(const t of e){if(!t?.gradient)continue;const e=t.gradient;e&&(a.gradient=(0,i.KH)(e,(a=>{const e=new d;return e.load(a),e})))}}async update(a,e){const{updateGradient:i}=await t.e(1708).then(t.bind(t,1708));i(a,e)}}}}]);